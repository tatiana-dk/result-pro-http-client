{"version":3,"sources":["../src/index.js","../src/utils/base.js","../src/utils/cache.js","../src/client.js"],"sourcesContent":["import { createClient, HttpError } from './client.js';\r\n\r\nexport { createClient, HttpError };\r\n\r\n// const api = createClient({\r\n//   baseURL: 'https://httpbin.org',\r\n//   headers: {  },\r\n//   timeout: 3000,\r\n//   beforeRequest: (options) => {\r\n//         const token = 'token';\r\n//         if (token) {\r\n//             options.headers = {\r\n//                 ...options.headers,\r\n//                 Authorization: `Bearer ${token}`,\r\n//             };\r\n//         }\r\n\r\n//         options._startTime = Date.now();\r\n\r\n//         return options;\r\n//     },\r\n//     afterResponse: async (response, options) => {\r\n//         const duration = Date.now() - options._startTime;\r\n//         const method = (options.method || 'GET').toUpperCase();\r\n//         const url = options.url;\r\n//         const status = response?.status || '—';\r\n\r\n//         console.log(`[${method}] ${url} — ${status} (${duration} мс)`);\r\n\r\n//         return response;\r\n//     },\r\n// });\r\n\r\n// api.get('/comments', {query: {postId: 1}})\r\n//   .then(data => console.log(data))\r\n//   .catch(err => console.error(err));\r\n\r\n// api.get('/status/404')\r\n//   .then(data => console.log(data))\r\n//   .catch(handleError);\r\n\r\n// const myController = new AbortController();\r\n\r\n// api.get('/delay/5', { signal: myController.signal })\r\n//   .then(data => console.log(data))\r\n//   .catch(handleError);\r\n\r\n// setTimeout(() => {myController.abort()}, 2000);\r\n\r\n// api.get('/bearer')\r\n//     .then(data => console.log(data))\r\n//     .catch(handleError);\r\n\r\n// api.post('/post', {\r\n//   retry: {\r\n//     maxAttempts: 4,\r\n//     baseDelayMs: 800,\r\n//     maxDelayMs: 15000,\r\n//     backoffFactor: 2.5\r\n//   }\r\n// })\r\n//     .then(data => console.log(data))\r\n//     .catch(handleError);\r\n\r\n// function handleError(err) {\r\n//     if (err instanceof HttpError) {\r\n//         if (err.isTimeout) console.log('Таймаут');\r\n//         else if (err.isAbort)   console.log('Отменено');\r\n//         else if (err.isNetwork)   console.log('Нет сети');\r\n//         else if (err.status >= 400 && err.status < 500)\r\n//             console.log('Ошибка клиента:', err.status);\r\n//         else\r\n//             console.log('Ошибка сервера:', err.status);\r\n//     }\r\n// }","export class HttpError extends Error {\r\n  constructor(status, statusText, response, message = '') {\r\n    super(message || `HTTP ${status} ${statusText}`);\r\n    this.name = 'HttpError';\r\n    this.status = status;\r\n    this.statusText = statusText;\r\n    this.response = response;      // оригинальный Response объект\r\n    this.isAbort = false;\r\n    this.isTimeout = false;\r\n    this.isNetwork = false;\r\n  }\r\n}\r\n\r\n// Вспомогательная функция: добавляет query-параметры к URL\r\nfunction buildUrl(url, query = {}) {\r\n  if (!query || Object.keys(query).length === 0) return url;\r\n\r\n  const params = new URLSearchParams();\r\n  for (const [key, value] of Object.entries(query)) {\r\n    if (value !== undefined && value !== null) {\r\n      params.append(key, value);\r\n    }\r\n  }\r\n  const queryString = params.toString();\r\n  return queryString ? `${url}?${queryString}` : url;\r\n};\r\n\r\n// Вспомогательная функция для нормализации ошибок\r\nexport function normalizeError(err, signal, timeoutId) {\r\n  if (err instanceof HttpError) {\r\n      return err;\r\n  }\r\n\r\n  if (err.name === 'AbortError') {\r\n      const error = new HttpError(0, 'Aborted', null, 'Request aborted');\r\n      error.isAbort = true;\r\n      error.isTimeout = !signal && !!timeoutId;\r\n      return error;\r\n  }\r\n\r\n  const error = new HttpError(0, 'Network Error', null, err.message || 'Network failure');\r\n  error.isNetwork = true;\r\n  return error;\r\n};\r\n\r\nexport function mergeHeaders(defaults, requestHeaders) {\r\n  return {\r\n    'Content-Type': 'application/json',\r\n    ...defaults,\r\n    ...requestHeaders,\r\n  };\r\n}\r\n\r\nexport function prepareBody(headers, body) {\r\n  if (body === undefined) return undefined;\r\n  if (headers['Content-Type'] === 'application/json') {\r\n    return JSON.stringify(body);\r\n  }\r\n  return body; // FormData, Blob, строка и т.д.\r\n}\r\n\r\nexport function getEffectiveSignal(optionsSignal, internalController) {\r\n  return optionsSignal || internalController.signal;\r\n}\r\n\r\nexport function calculateRetryDelay(attempt, baseDelayMs, backoffFactor, maxDelayMs) {\r\n  const delay = baseDelayMs * Math.pow(backoffFactor, attempt - 1);\r\n  return Math.min(delay, maxDelayMs);\r\n}\r\n\r\nexport function shouldRetry(normalizedError, maxAttempts, attempt) {\r\n  const isRetryable =\r\n    normalizedError.isTimeout ||\r\n    normalizedError.isNetwork ||\r\n    (normalizedError.status >= 500 && normalizedError.status < 600) ||\r\n    normalizedError.status === 429;\r\n\r\n  return isRetryable && attempt < maxAttempts;\r\n}\r\n\r\nexport function getRetryOptions(retry) {\r\n  retry = retry ?? {};\r\n  const maxAttempts = retry.maxAttempts ?? 1; // 1 = без повторов\r\n  const baseDelayMs = retry.baseDelayMs ?? 1000;\r\n  const maxDelayMs = retry.maxDelayMs ?? 10000;\r\n  const backoffFactor = retry.backoffFactor ?? 2;\r\n\r\n  return {maxAttempts, baseDelayMs, maxDelayMs, backoffFactor};\r\n}\r\n\r\nexport function buildFullUrl(url, query, baseURL) {\r\n  let full = url;\r\n  if (query) full = buildUrl(full, query);\r\n  if (!full.startsWith('http')) {\r\n    full = baseURL + (full.startsWith('/') ? '' : '/') + full;\r\n  }\r\n  return full;\r\n}\r\n\r\nexport function isGetRequest(options) {\r\n  return (options.method || 'GET') === 'GET';\r\n}\r\n\r\nexport async function parseResponse(response) {\r\n  const contentType = response.headers.get('content-type') || '';\r\n  if (contentType.includes('application/json')) {\r\n    return await response.json();\r\n  }\r\n  return await response.text();\r\n}","// src/utils/cache.js\r\n\r\n/**\r\n * Пытается получить данные из кэша.\r\n * Возвращает данные, если они есть и не просрочены, иначе null.\r\n *\r\n * @param {string} url - ключ кэша (обычно полный URL)\r\n * @param {number} cacheTTL - время жизни кэша в миллисекундах\r\n * @param {Map} cache - объект кэша (Map)\r\n * @returns {any | null} данные из кэша или null\r\n */\r\nexport function tryGetFromCache(url, cacheTTL, cache) {\r\n  if (cacheTTL <= 0) return null;\r\n\r\n  const cached = cache.get(url);\r\n  if (!cached) return null;\r\n\r\n  const age = Date.now() - cached.timestamp;\r\n  if (age < cacheTTL) {\r\n    console.debug(`[cache hit] ${url} (age: ${Math.round(age / 1000)} сек)`);\r\n    return cached.data;\r\n  }\r\n\r\n  console.debug(`[cache expired] ${url} (age: ${Math.round(age / 1000)} сек)`);\r\n  cache.delete(url);\r\n  return null;\r\n}\r\n\r\n/**\r\n * Сохраняет данные в кэш.\r\n *\r\n * @param {string} url - ключ кэша\r\n * @param {any} data - данные для сохранения\r\n * @param {Map} cache - объект кэша\r\n */\r\nexport function saveToCache(url, data, cache) {\r\n  cache.set(url, {\r\n    data,\r\n    timestamp: Date.now(),\r\n  });\r\n  console.debug(`[cache saved] ${url}`);\r\n}","import {\r\n    HttpError,\r\n    normalizeError,\r\n    mergeHeaders,\r\n    prepareBody,\r\n    getEffectiveSignal,\r\n    calculateRetryDelay,\r\n    shouldRetry,\r\n    getRetryOptions,\r\n    buildFullUrl,\r\n    isGetRequest,\r\n    parseResponse\r\n} from \"./utils/base.js\";\r\n\r\nimport { tryGetFromCache, saveToCache } from './utils/cache.js';\r\n\r\nexport { HttpError };\r\n\r\nexport function createClient(config = {}) {\r\n    const {\r\n        baseURL = '',\r\n        headers: defaultHeaders = {},\r\n        timeout,\r\n        cacheTTL = 0,\r\n        beforeRequest,\r\n        afterResponse\r\n    } = config;\r\n\r\n    const cache = new Map();\r\n\r\n    async function performUploadWithProgress(options) {\r\n        return new Promise((resolve, reject) => {\r\n            const fullUrl = buildFullUrl(options.url, options.query, baseURL);\r\n            const mergedHeaders = mergeHeaders(defaultHeaders, options.headers);\r\n            const body = prepareBody(mergedHeaders, options.body);\r\n\r\n            const xhr = new XMLHttpRequest();\r\n            xhr.open(options.method, fullUrl, true);\r\n\r\n            // Устанавливаем заголовки\r\n            Object.entries(mergedHeaders).forEach(([key, value]) => {\r\n                if (value !== undefined && value !== null) {\r\n                    xhr.setRequestHeader(key, value);\r\n                }\r\n            });\r\n\r\n            // Прогресс загрузки\r\n            if (options.onUploadProgress && typeof options.onUploadProgress === 'function') {\r\n                xhr.upload.onprogress = (e) => {\r\n                    if (e.lengthComputable) {\r\n                        options.onUploadProgress({\r\n                            loaded: e.loaded,\r\n                            total: e.total,\r\n                            percent: Math.round((e.loaded / e.total) * 100)\r\n                        });\r\n                    }\r\n                };\r\n            }\r\n\r\n            // Таймаут\r\n            if (options.timeout ?? timeout) {\r\n                xhr.timeout = options.timeout ?? timeout;\r\n                xhr.ontimeout = () => {\r\n                    reject(Object.assign(new Error('Request timeout'), { isTimeout: true }));\r\n                };\r\n            }\r\n\r\n            // Отмена через AbortSignal\r\n            let aborted = false;\r\n            if (options.signal) {\r\n                options.signal.addEventListener('abort', () => {\r\n                    aborted = true;\r\n                    xhr.abort();\r\n                    reject(new Error('Request aborted'));\r\n                });\r\n            }\r\n\r\n            xhr.onload = () => {\r\n                if (aborted) return;\r\n\r\n                if (xhr.status >= 200 && xhr.status < 300) {\r\n                    let data;\r\n                    const contentType = xhr.getResponseHeader('content-type') || '';\r\n\r\n                    try {\r\n                        if (contentType.includes('application/json')) {\r\n                            data = JSON.parse(xhr.responseText);\r\n                        } else {\r\n                            data = xhr.responseText;\r\n                        }\r\n                        resolve(data);\r\n                    } catch (e) {\r\n                        reject(new Error(`Parse error: ${e.message}`));\r\n                    }\r\n                } else {\r\n                    const err = new HttpError(xhr.status, xhr.statusText, null);\r\n                    err.responseText = xhr.responseText;\r\n                    reject(err);\r\n                }\r\n            };\r\n\r\n            xhr.onerror = () => reject(new Error('Network error'));\r\n            xhr.onabort = () => {\r\n                if (!aborted) reject(new Error('Request aborted'));\r\n            };\r\n\r\n            xhr.send(body || null);\r\n        });\r\n    }\r\n\r\n    async function performRequestOnce(options) {\r\n        const fullUrl = buildFullUrl(options.url, options.query, baseURL);\r\n\r\n        // Проверка кэша (кэш не используем, если есть прогресс — чтобы показывать реальный процесс)\r\n        const isGet = isGetRequest(options);\r\n        const canUseCache = isGet && cacheTTL > 0 && !options.onDownloadProgress;\r\n\r\n        if (canUseCache) {\r\n            const cachedData = tryGetFromCache(fullUrl, cacheTTL, cache);\r\n            if (cachedData !== null) {\r\n                // для кэша можно сразу эмулировать прогресс 100%\r\n                options.onDownloadProgress?.({\r\n                    loaded: 1,\r\n                    total: 1,\r\n                    percent: 100,\r\n                    fromCache: true\r\n                });\r\n                return cachedData;\r\n            }\r\n        }\r\n\r\n        const mergedHeaders = mergeHeaders(defaultHeaders, options.headers);\r\n        const body = prepareBody(mergedHeaders, options.body);\r\n\r\n        // Если есть onUploadProgress и метод с телом → используем XHR\r\n        const method = (options.method || 'GET').toUpperCase();\r\n        const hasBody = body !== undefined;\r\n        const needsUploadProgress = options.onUploadProgress && ['POST', 'PUT', 'PATCH'].includes(method);\r\n\r\n        if (needsUploadProgress && hasBody) {\r\n            // ... (твой существующий код performUploadWithProgress)\r\n            const data = await performUploadWithProgress({\r\n                ...options,\r\n                method,\r\n                url: fullUrl,\r\n                headers: mergedHeaders,\r\n                body,\r\n            });\r\n            return data;\r\n        }\r\n\r\n        // ────────────────────────────────────────────────\r\n        // Обычный fetch + download progress\r\n        // ────────────────────────────────────────────────\r\n        const internalController = new AbortController();\r\n        const effectiveSignal = getEffectiveSignal(options.signal, internalController);\r\n\r\n        let timeoutId;\r\n        const ms = options.timeout ?? timeout ?? 0;\r\n        if (ms > 0 && !options.signal) {\r\n            timeoutId = setTimeout(() => internalController.abort(), ms);\r\n        }\r\n\r\n        try {\r\n            const response = await fetch(fullUrl, {\r\n                method,\r\n                headers: mergedHeaders,\r\n                body,\r\n                signal: effectiveSignal,\r\n            });\r\n\r\n            let processedResponse = response;\r\n            if (afterResponse) {\r\n                const modified = await afterResponse(response, options);\r\n                if (modified) processedResponse = modified;\r\n            }\r\n\r\n            if (!processedResponse.ok) {\r\n                throw new HttpError(processedResponse.status, processedResponse.statusText, processedResponse);\r\n            }\r\n\r\n            // ─── Download Progress ────────────────────────────────────────\r\n            const onDownloadProgress = options.onDownloadProgress;\r\n            const hasProgress = onDownloadProgress && typeof onDownloadProgress === 'function';\r\n\r\n            let total = Number(processedResponse.headers.get('content-length')) || 0;\r\n            let loaded = 0;\r\n\r\n            const reader = processedResponse.body.getReader();\r\n            const chunks = [];\r\n\r\n            while (true) {\r\n                const { done, value } = await reader.read();\r\n                if (done) break;\r\n\r\n                if (value) {\r\n                    chunks.push(value);\r\n                    loaded += value.length;\r\n\r\n                    if (hasProgress) {\r\n                        onDownloadProgress({\r\n                            loaded,\r\n                            total: total || loaded,         // если total неизвестен — используем loaded\r\n                            percent: total ? Math.round((loaded / total) * 100) : 0,\r\n                            estimatedTotal: total > 0,\r\n                            fromCache: false\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Собираем ответ из чанков\r\n            const blob = new Blob(chunks);\r\n            let data;\r\n\r\n            const contentType = processedResponse.headers.get('content-type') || '';\r\n            if (contentType.includes('application/json')) {\r\n                data = JSON.parse(await blob.text());\r\n            } else {\r\n                data = await blob.text(); // или .arrayBuffer(), .blob() и т.д.\r\n            }\r\n\r\n            // ─── Кэширование ──────────────────────────────────────────────\r\n            if (canUseCache) {\r\n                saveToCache(fullUrl, data, cache);\r\n            }\r\n\r\n            // Финальный прогресс 100% (на случай, если total был неточным)\r\n            if (hasProgress && total > 0) {\r\n                onDownloadProgress({\r\n                    loaded: total,\r\n                    total,\r\n                    percent: 100,\r\n                    estimatedTotal: true,\r\n                    fromCache: false\r\n                });\r\n            }\r\n\r\n            return data;\r\n        } catch (err) {\r\n            if (afterResponse) {\r\n                await afterResponse(null, options, err).catch(() => {});\r\n            }\r\n            throw err;\r\n        } finally {\r\n            if (timeoutId) clearTimeout(timeoutId);\r\n        }\r\n    }\r\n\r\n    async function request(options) {        \r\n        let currentOptions = { ...options };\r\n\r\n        if (beforeRequest) {\r\n            currentOptions = (await beforeRequest(currentOptions)) || currentOptions;\r\n        }\r\n\r\n        const { maxAttempts, baseDelayMs, maxDelayMs, backoffFactor } = getRetryOptions(currentOptions.retry);\r\n\r\n        if (maxAttempts <= 1) {\r\n            return performRequestOnce(currentOptions);\r\n        }\r\n\r\n        let attempt = 1;\r\n        let lastError;\r\n\r\n        while (true) {\r\n            try {\r\n                return await performRequestOnce(currentOptions);\r\n            } catch (err) {\r\n                lastError = err;\r\n                const normalized = normalizeError(err, currentOptions.signal);\r\n\r\n                if (!shouldRetry(normalized, maxAttempts, attempt)) {\r\n                    throw normalized;\r\n                }\r\n\r\n                const delay = calculateRetryDelay(attempt, baseDelayMs, backoffFactor, maxDelayMs);\r\n                await new Promise(r => setTimeout(r, delay));\r\n                attempt++;\r\n            }\r\n        }\r\n    }\r\n\r\n    return {\r\n        request,\r\n        get:    (url, opts = {}) => request({ method: 'GET',    url, ...opts }),\r\n        post:   (url, body, opts = {}) => request({ method: 'POST',   url, body, ...opts }),\r\n        put:    (url, body, opts = {}) => request({ method: 'PUT',    url, body, ...opts }),\r\n        patch:  (url, body, opts = {}) => request({ method: 'PATCH',  url, body, ...opts }),\r\n        del:    (url, opts = {}) => request({ method: 'DELETE', url, ...opts }),\r\n    };\r\n}"],"mappings":"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","names":["error"]}